# 数据库理论知识

## ACID
- Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样
- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作
- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）
- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 

## CAP
- CAP:Consistency:一致性、Availability:可用性、Partition tolerance:分区容错性
- 最多只能同时满足两项

### 一致性
- 多个副本之间是否能够保持数据一致的特性，即一个节点数据更新后，另一个节点的数据也应到更新，这是一种强一致性
### 可用性
- 可用性是指系统提供的服务必须一直处于可用状态，对于用户的每一个操作请求都可以在有限的时间内返回结果
### 分区容错性
- 分区容错性约束了一个分布式系统具有的特性，分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障

## BASE
- Basically Availabe(基本可用)、Soft state(软状态)和Eventually consistent(最终一致性)，是对CAP中一致性和可用性权衡的结果

### 基本可用
- 响应时间上的损失:正常来说响应时0.5s，发生故障时可以维持在2～3s左右
- 功能上的损失:服务降级方式保证基本可用
### 软状态
- 运行系统中的数据存在中间状态，并认为该中间状态的存在不会影响整个系统的可用性，即运行系统在不同节点上的数据副本之间进行数据同步的过程存在延时
### 最终一致性
- 系统中所有的数据副本在经过一段时间的同步后，最终能够达到一个一致的状态
### 最终一致性的变体
- 因果一致性:如果进程A在更新完某个数据后通知了进程B，那么进程B之后对该数据的访问都应该能够获取A更新后的最新值，并且如果进程B要对该数据进行更新的话，务必基于进程A更新后的最新值
- 读己之所写:进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值
- 会话一致性:对系统数据的访问过程框定在了一个会话当中:系统能保证在同一个有效的会话中实现"读己之所写"的一致性，执行更新操作后，客户端能够在同一个会话中始终读取到该数据项的最新值
- 单调读一致性:如果一个进程从系统中读取出一个数据的某值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值
- 单调写一致性:一个系统需要能保证来自同一个进程的写操作被顺序执行

## [Raft](https://raft.github.io/)

## Paxos(帕克索斯)
## 2PC
https://blog.csdn.net/zjj2006/article/details/112557680
## 3PC
## Percolator
https://pingcap.com/zh/blog/percolator-and-txn
## TCC
## ZAB协议
## MVCC
## WAL
## Index
### B-tree
### B+tree
### LSM
## Checkpoint
## Compaction
## 建模
### 范式
## 维度(Kimball) 
### 事实表
### 维度表
## 领域概念建模